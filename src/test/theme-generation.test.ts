/**
 * Tests for theme CSS generation
 *
 * Verifies that the generate-themes.js script produces valid CSS
 * with all required theme variables.
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import { execSync } from 'child_process'
import fs from 'fs'
import path from 'path'

const SCRIPT_PATH = path.join(__dirname, '../../scripts/generate-themes.js')
const OUTPUT_PATH = path.join(__dirname, '../../src/themes.generated.css')

describe('Theme CSS Generation', () => {
  // Backup the existing file if it exists
  let backupContent: string | null = null

  beforeEach(() => {
    if (fs.existsSync(OUTPUT_PATH)) {
      backupContent = fs.readFileSync(OUTPUT_PATH, 'utf-8')
    }
  })

  afterEach(() => {
    // Restore backup if it existed
    if (backupContent) {
      fs.writeFileSync(OUTPUT_PATH, backupContent, 'utf-8')
    }
  })

  describe('Script Execution', () => {
    it('should run without errors', () => {
      // Arrange & Act
      const execute = () => {
        execSync(`node "${SCRIPT_PATH}"`, { encoding: 'utf-8' })
      }

      // Assert - should not throw
      expect(execute).not.toThrow()
    })

    it('should create the output file', () => {
      // Arrange - Remove output file if it exists
      if (fs.existsSync(OUTPUT_PATH)) {
        fs.unlinkSync(OUTPUT_PATH)
      }

      // Act
      execSync(`node "${SCRIPT_PATH}"`, { encoding: 'utf-8' })

      // Assert
      expect(fs.existsSync(OUTPUT_PATH)).toBe(true)
    })

    it('should output success message with theme count', () => {
      // Act
      const output = execSync(`node "${SCRIPT_PATH}"`, { encoding: 'utf-8' })

      // Assert
      expect(output).toContain('âœ…')
      expect(output).toContain('Themes:')
      expect(output).toContain('light')
      expect(output).toContain('sepia')
      expect(output).toContain('dark')
    })
  })

  describe('Generated CSS Structure', () => {
    let generatedCss: string

    beforeEach(() => {
      // Ensure themes are generated
      execSync(`node "${SCRIPT_PATH}"`, { encoding: 'utf-8' })
      generatedCss = fs.readFileSync(OUTPUT_PATH, 'utf-8')
    })

    it('should include generated file header comment', () => {
      // Assert
      expect(generatedCss).toContain('Generated by scripts/generate-themes.js')
      expect(generatedCss).toContain('DO NOT EDIT')
    })

    it('should include :root selector', () => {
      // Assert
      expect(generatedCss).toContain(':root {')
    })

    it('should include [data-theme="dark"] selector', () => {
      // Assert
      expect(generatedCss).toContain('[data-theme="dark"] {')
    })

    it('should include [data-theme="sepia"] selector', () => {
      // Assert
      expect(generatedCss).toContain('[data-theme="sepia"] {')
    })

    it('should have all three theme selectors', () => {
      // Assert
      expect(generatedCss).toMatch(/:root\s*{/)
      const darkMatches = generatedCss.match(/\[data-theme="dark"\]\s*{/g)
      const sepiaMatches = generatedCss.match(/\[data-theme="sepia"\]\s*{/g)
      expect(darkMatches?.length).toBeGreaterThanOrEqual(1)
      expect(sepiaMatches?.length).toBeGreaterThanOrEqual(1)
    })
  })

  describe('Required CSS Variables', () => {
    const requiredVars = [
      '--bg-cream',
      '--bg-paper',
      '--bg-ivory',
      '--bg-warm',
      '--text-main',
      '--text-dim',
      '--text-soft',
      '--surface-panel',
      '--surface-card',
      '--surface-hover',
      '--border-subtle',
      '--glass-bg',
      '--glass-border',
      '--glass-shadow',
      '--accent',
      '--accent-warm',
      '--shadow-premium'
    ]

    let generatedCss: string

    beforeEach(() => {
      execSync(`node "${SCRIPT_PATH}"`, { encoding: 'utf-8' })
      generatedCss = fs.readFileSync(OUTPUT_PATH, 'utf-8')
    })

    it('should include all required variables in :root', () => {
      // Assert
      requiredVars.forEach((varName) => {
        expect(generatedCss).toContain(`${varName}:`)
      })
    })

    it('should include all required variables in dark theme', () => {
      // Arrange - Extract dark theme section
      const darkMatch = generatedCss.match(/\[data-theme="dark"\]\s*{([^}]+)}/)
      expect(darkMatch).toBeTruthy()

      const darkTheme = darkMatch ? darkMatch[1] : ''

      // Assert - Check that key variables are present
      expect(darkTheme).toContain('--bg-cream:')
      expect(darkTheme).toContain('--text-main:')
      expect(darkTheme).toContain('--surface-panel:')
    })

    it('should include all required variables in sepia theme', () => {
      // Arrange - Extract sepia theme section
      const sepiaMatch = generatedCss.match(/\[data-theme="sepia"\]\s*{([^}]+)}/)
      expect(sepiaMatch).toBeTruthy()

      const sepiaTheme = sepiaMatch ? sepiaMatch[1] : ''

      // Assert - Check that key variables are present
      expect(sepiaTheme).toContain('--bg-cream:')
      expect(sepiaTheme).toContain('--text-main:')
      expect(sepiaTheme).toContain('--surface-panel:')
    })
  })

  describe('CSS Variable Format', () => {
    let generatedCss: string

    beforeEach(() => {
      execSync(`node "${SCRIPT_PATH}"`, { encoding: 'utf-8' })
      generatedCss = fs.readFileSync(OUTPUT_PATH, 'utf-8')
    })

    it('should use valid CSS syntax for color variables', () => {
      // Assert - Colors should be hex, rgba, or named colors
      const colorVars = generatedCss.matchAll(/--(?:bg-cream|text-main|accent):\s*([^;]+);/g)
      for (const match of colorVars) {
        const value = match[1].trim()
        const isValidColor =
          value.startsWith('#') ||
          value.startsWith('rgba') ||
          value.startsWith('rgb')
        expect(isValidColor).toBe(true)
      }
    })

    it('should use valid CSS syntax for shadow variables', () => {
      // Assert - Shadows should use box-shadow syntax (offset-x blur-radius spread-radius color)
      const shadowVars = generatedCss.matchAll(/--shadow-premium:\s*([^;]+);/g)
      for (const match of shadowVars) {
        const value = match[1].trim()
        // CSS box-shadow format: 0 25px 50px -12px rgba(0, 0, 0, 0.25)
        expect(value).toMatch(/^[\d-\s\w]+rgba?\(/)
      }
    })
  })

  describe('Theme Consistency', () => {
    let generatedCss: string

    beforeEach(() => {
      execSync(`node "${SCRIPT_PATH}"`, { encoding: 'utf-8' })
      generatedCss = fs.readFileSync(OUTPUT_PATH, 'utf-8')
    })

    it('should have same number of variables in all themes', () => {
      // Helper to count variables in a theme block
      const countVars = (block: string) => {
        return (block.match(/--[\w-]+:/g) || []).length
      }

      // Extract theme blocks
      const rootMatch = generatedCss.match(/:root\s*{([^}]+)}/)
      const darkMatch = generatedCss.match(/\[data-theme="dark"\]\s*{([^}]+)}/)
      const sepiaMatch = generatedCss.match(/\[data-theme="sepia"\]\s*{([^}]+)}/)

      expect(rootMatch).toBeTruthy()
      expect(darkMatch).toBeTruthy()
      expect(sepiaMatch).toBeTruthy()

      const rootCount = rootMatch ? countVars(rootMatch[1]) : 0
      const darkCount = darkMatch ? countVars(darkMatch[1]) : 0
      const sepiaCount = sepiaMatch ? countVars(sepiaMatch[1]) : 0

      // All themes should have the same number of variables
      expect(rootCount).toBe(darkCount)
      expect(rootCount).toBe(sepiaCount)
      expect(darkCount).toBe(sepiaCount)
    })

    it('should have consistent variable names across themes', () => {
      // Helper to extract variable names from a block
      const extractVarNames = (block: string) => {
        const matches = block.match(/--[\w-]+:/g) || []
        return new Set(matches.map((m) => m.replace(':', '')))
      }

      // Extract theme blocks
      const rootMatch = generatedCss.match(/:root\s*{([^}]+)}/)
      const darkMatch = generatedCss.match(/\[data-theme="dark"\]\s*{([^}]+)}/)
      const sepiaMatch = generatedCss.match(/\[data-theme="sepia"\]\s*{([^}]+)}/)

      const rootVars = rootMatch ? extractVarNames(rootMatch[1]) : new Set()
      const darkVars = darkMatch ? extractVarNames(darkMatch[1]) : new Set()
      const sepiaVars = sepiaMatch ? extractVarNames(sepiaMatch[1]) : new Set()

      // All themes should have the same variable names
      expect(rootVars).toEqual(darkVars)
      expect(rootVars).toEqual(sepiaVars)
    })
  })
})
